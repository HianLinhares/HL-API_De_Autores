// MÃ‰TODOS NÃƒO IMPLEMENTADOS E MESMO ASSIM FUNCIONANDO (QUERY DERIVADA POR CONVENÃ‡ÃƒO DE NOMES)

package Hian.Linhares.HL_API_De_Autores.repository;

import Hian.Linhares.HL_API_De_Autores.model.Autor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.UUID;

@Repository
public interface AutorRepository extends JpaRepository<Autor, UUID> {

    List<Autor> findByNome(String nome);

    List<Autor> findByNacionalidade(String nacionalidade);

    List<Autor> findByNomeAndNacionalidade(String nome, String nacionalidade);

}

Esse Ã© um dos maiores poderes do Spring Data JPA: vocÃª nÃ£o precisa implementar manualmente os mÃ©todos do Repository!
O Spring faz isso automaticamente pra vocÃª com base na convenÃ§Ã£o dos nomes dos mÃ©todos.

ðŸ”¹ Resumo:

âœ… VocÃª nÃ£o implementa nada manualmente.
âœ… O Spring gera o SQL automÃ¡tico com base no nome do mÃ©todo.
âœ… Isso Ã© chamado de "query derivada por convenÃ§Ã£o de nomes".

---------------------------------------------------------------------------------------------------------------------------------------------------------

// INVERSÃƒO DE CONTROLE INJEÃ‡ÃƒO DE DEPENDÃŠNCIA

No Spring, quando vocÃª precisa usar outra classe (como o AutorRepository dentro do AutorService), vocÃª nÃ£o cria ela com new, porque quem gerencia a criaÃ§Ã£o e o
 ciclo de vida dos objetos Ã© o Spring Container.
Isso Ã© chamado de InversÃ£o de Controle (IoC) e Ã© implementado por meio da InjeÃ§Ã£o de DependÃªncia (DI).

âœ… Tipos de InjeÃ§Ã£o:

Via construtor âœ… (recomendada)

Via @Autowired no campo

Via @Autowired no setter

ðŸ’¡ Por que usar o construtor (como no seu exemplo)?

Vantagens:

âœ… Permite que o Spring injete automaticamente a dependÃªncia (AutorRepository) no momento da criaÃ§Ã£o do AutorService.

âœ… Ã‰ mais seguro, porque o campo repository Ã© final (nÃ£o muda mais depois da construÃ§Ã£o).

âœ… Facilita testes unitÃ¡rios, pois vocÃª pode criar a classe manualmente passando um mock no construtor.

âœ… Dispensa o uso explÃ­cito de @Autowired (Spring detecta automaticamente se hÃ¡ um Ãºnico construtor).

âœ… Evita problemas de injeÃ§Ã£o nula (null pointer), porque o campo Ã© inicializado no construtor.

ðŸ”§ Como o Spring faz:

Quando o Spring sobe o contexto e vÃª a classe marcada com @Service, ele:

Cria o AutorRepository (porque Ã© um @Repository).

VÃª que AutorService tem um construtor que recebe AutorRepository.

Injeta automaticamente a instÃ¢ncia correta.